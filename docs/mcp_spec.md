    # Pandacea Model Context Protocol (MCP) Specification (v1.0 - Draft)

    This document specifies the Model Context Protocol (MCP), a protocol designed for requesting access to data or capabilities from consent-managed resources, particularly in edge or decentralized environments.

    ## 1. Overview

    MCP facilitates communication between a *Requestor* (e.g., an application, an AI agent) and a *Responder* (typically a Consent Manager acting on behalf of a user or data owner). The protocol defines message structures for making requests and receiving responses, incorporating cryptographic signatures for authenticity and integrity, and detailed purpose descriptions (PurposeDNA) for transparency and consent management.

    ## 2. Message Format

    MCP messages are encoded using Protocol Buffers (proto3 syntax).

    See [`mcp.proto`](./mcp.proto) for the definitive schema definition.

    ## 3. Core Messages

    ### 3.1. `MCPRequest`

    Represents a request initiated by a Requestor.

    **Key Fields:**

    *   `request_id` (string, UUID): Unique identifier for this request.
    *   `timestamp` (google.protobuf.Timestamp): Time the request was created.
    *   `requestor_identity` (RequestorIdentity): Information about the requestor.
    *   `purpose_dna` (PurposeDNA): Detailed description of the purpose.
    *   `permissions` (repeated PermissionSpecification): List of specific permissions sought.
    *   `request_expiry` (google.protobuf.Timestamp, optional): Time after which the request is invalid.
    *   `signature` (CryptoSignature): Signature covering the request fields (see Signing Process).
    *   `mcp_version` (string): Protocol version (e.g., "1.0.0").
    *   `related_request_id` (string, optional): ID of a previous related request.
    *   `extensions` (repeated google.protobuf.Any, optional): For future protocol evolution.

    ### 3.2. `MCPResponse`

    Represents a response generated by a Responder.

    **Key Fields:**

    *   `response_id` (string, UUID): Unique identifier for this response.
    *   `request_id` (string): ID of the `MCPRequest` this responds to.
    *   `timestamp` (google.protobuf.Timestamp): Time the response was generated.
    *   `status` (Status enum): Overall outcome (APPROVED, DENIED, etc.).
    *   `status_message` (string, optional): Human-readable context for the status.
    *   `permission_statuses` (repeated PermissionStatus, optional): Per-permission outcomes (required if status is `PARTIALLY_APPROVED`).
    *   `response_payload` (bytes, optional): Data returned for approved READ requests.
    *   `consent_receipt` (bytes, optional): Cryptographic proof of the consent decision.
    *   `signature` (CryptoSignature): Signature covering the response fields (see Signing Process).
    *   `mcp_version` (string): Protocol version (e.g., "1.0.0").
    *   `extensions` (repeated google.protobuf.Any, optional): For future protocol evolution.

    ## 4. Supporting Structures

    *   **`RequestorIdentity`**: Contains `pseudonym_id`, `public_key` (bytes, e.g., Ed25519), and optional `attestations` (URLs).
    *   **`PurposeDNA`**: Details the purpose with `purpose_id`, `primary_purpose_category` (enum), `specific_purpose_description`, `data_types_involved`, processing/storage details, lineage info (`origin_request_id`, `transformation_description`), expiry, and optional `agent_metadata` (Struct).
    *   **`PermissionSpecification`**: Defines a resource (`resource_identifier`), an `Action` (READ, WRITE, EXECUTE, OBSERVE), and optional `constraints` (Struct).
    *   **`CryptoSignature`**: Holds `key_id`, `algorithm` (string, e.g., "Ed25519"), and `signature` (bytes).
    *   **`Status` (enum)**: APPROVED, PARTIALLY_APPROVED, DENIED, ERROR, PENDING.
    *   **`PermissionStatus`**: Links back to a `PermissionSpecification` and indicates if it was `granted` with an optional `reason`.

    ## 5. Validation

    Implementations MUST perform validation on received messages.
    The reference implementation (`pandacea-mcp` crate) provides a multi-stage validation process:

    1.  **Syntax Validation**: Checks for required fields, correct formats (timestamps, enums), non-empty strings where required, basic structural integrity, request/purpose expiration, basic signature structure.
    2.  **Semantic Validation**: (Implementation Specific) Checks for logical consistency, purpose/permission coherence, constraint logic evaluation against context.
    3.  **Security Validation**: Verifies the cryptographic signature using the appropriate public key.

    ## 6. Signing Process

    1.  **Prepare Data**: Create a copy of the `MCPRequest` or `MCPResponse` message.
    2.  **Clear Signature**: Set the `signature` field in the copy to `None`.
    3.  **Canonicalize & Serialize**: Serialize the modified message copy into bytes. **Note:** Standard Protobuf is not canonical. For cross-implementation signature compatibility, a defined canonical serialization scheme MUST be used.
    4.  **Sign**: Compute the cryptographic signature of the serialized bytes using the sender's private key and chosen algorithm (e.g., Ed25519).
    5.  **Populate Signature**: Create a `CryptoSignature` message containing the `key_id` (identifying the public key), `algorithm` name, and the computed `signature` bytes. Set this as the `signature` field on the *original* message.
    6.  **Serialize Original**: Serialize the original message (now including the populated signature field) for transmission.

    ## 7. Verification Process

    1.  **Deserialize**: Deserialize the received message bytes into an `MCPRequest` or `MCPResponse`.
    2.  **Extract Signature Info**: Get the `CryptoSignature` message from the `signature` field. If missing, fail.
    3.  **Prepare Data**: Create a copy of the deserialized message.
    4.  **Clear Signature**: Set the `signature` field in the copy to `None`.
    5.  **Canonicalize & Serialize**: Serialize the modified message copy using the *exact same canonical scheme* used during signing.
    6.  **Obtain Public Key**:
        *   For `MCPRequest`: Get the `public_key` bytes from the `requestor_identity` field.
        *   For `MCPResponse`: Obtain the expected responder's public key bytes through a trusted mechanism, potentially using the `key_id` from the `CryptoSignature` for lookup.
    7.  **Verify**: Use the obtained public key, the serialized bytes (from step 5), the signature bytes (from step 2), and the algorithm name (from step 2) to perform cryptographic verification.

    ## 8. Versioning

    The `mcp_version` field in both request and response messages uses Semantic Versioning (Major.Minor.Patch, e.g., "1.0.0").

    *   **PATCH** changes are backward-compatible bug fixes.
    *   **MINOR** changes introduce new, backward-compatible functionality (e.g., adding optional fields, new enum values). Implementations should ignore unknown fields or enum values they don't support.
    *   **MAJOR** changes introduce backward-incompatible modifications.

    Implementations should check the version and potentially reject messages with incompatible major versions.

    ## 9. Extensions

    The `extensions` field (`repeated google.protobuf.Any`) allows for future protocol evolution without breaking compatibility for implementations that don't understand the extensions.

    ## 10. Constraints

    The `constraints` field within `PermissionSpecification` uses `google.protobuf.Struct` for flexible key-value definitions. Implementations define the supported constraint keys and their evaluation logic against a `RequestContext`. Examples:

    *   `"allowed_start_time"`: RFC3339 string
    *   `"allowed_end_time"`: RFC3339 string
    *   `"max_frequency_per_hour"`: number

    Constraint evaluation is typically part of Semantic Validation.