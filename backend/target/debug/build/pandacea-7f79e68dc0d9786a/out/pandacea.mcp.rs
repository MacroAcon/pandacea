// This file is @generated by prost-build.
/// Main MCP request message sent by requestors to responders
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct McpRequest {
    /// Unique identifier for this request
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
    /// MCP version used
    #[prost(string, tag = "2")]
    pub mcp_version: ::prost::alloc::string::String,
    /// Information about the requestor
    #[prost(message, optional, tag = "3")]
    pub requestor_identity: ::core::option::Option<RequestorIdentity>,
    /// Purpose for data access
    #[prost(message, optional, tag = "4")]
    pub purpose_dna: ::core::option::Option<PurposeDna>,
    /// What permission is being requested
    #[prost(message, optional, tag = "5")]
    pub permission_specification: ::core::option::Option<PermissionSpecification>,
    /// For backward compatibility - list of permissions (use permission_specification instead)
    #[prost(message, repeated, tag = "6")]
    pub permissions: ::prost::alloc::vec::Vec<PermissionSpecification>,
    /// Compensation offered for data access
    #[prost(message, optional, tag = "7")]
    pub compensation_model: ::core::option::Option<CompensationModel>,
    /// Trust credentials and attestations
    #[prost(message, optional, tag = "10")]
    pub trust_information: ::core::option::Option<TrustInformation>,
    /// Authentication information
    #[prost(message, optional, tag = "11")]
    pub authentication_info: ::core::option::Option<AuthenticationInfo>,
    /// Digital signature of canonical request
    #[prost(message, optional, tag = "12")]
    pub signature: ::core::option::Option<CryptoSignature>,
    /// Additional metadata as needed
    #[prost(message, optional, tag = "13")]
    pub metadata: ::core::option::Option<::prost_types::Struct>,
    /// Related request identifier (for multi-step or follow-up requests)
    #[prost(string, tag = "16")]
    pub related_request_id: ::prost::alloc::string::String,
    /// Context data for additional request information
    #[prost(message, optional, tag = "17")]
    pub context_data: ::core::option::Option<::prost_types::Struct>,
    /// Timestamp when the request was created
    #[prost(oneof = "mcp_request::RequestTime", tags = "8, 14")]
    pub request_time: ::core::option::Option<mcp_request::RequestTime>,
    /// When this request expires
    #[prost(oneof = "mcp_request::ExpiryTime", tags = "9, 15")]
    pub expiry_time: ::core::option::Option<mcp_request::ExpiryTime>,
}
/// Nested message and enum types in `McpRequest`.
pub mod mcp_request {
    /// Timestamp when the request was created
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum RequestTime {
        #[prost(message, tag = "8")]
        Timestamp(::prost_types::Timestamp),
        #[prost(message, tag = "14")]
        RequestTimestamp(::prost_types::Timestamp),
    }
    /// When this request expires
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ExpiryTime {
        #[prost(message, tag = "9")]
        Expiration(::prost_types::Timestamp),
        #[prost(message, tag = "15")]
        RequestExpiry(::prost_types::Timestamp),
    }
}
/// Response from responders to requestors
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct McpResponse {
    /// Same ID as the request
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
    /// MCP version used
    #[prost(string, tag = "2")]
    pub mcp_version: ::prost::alloc::string::String,
    /// Information about the responder
    #[prost(message, optional, tag = "3")]
    pub responder_identity: ::core::option::Option<ResponderIdentity>,
    /// Timestamp when the response was created
    #[prost(message, optional, tag = "4")]
    pub response_timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Response status code
    #[prost(enumeration = "mcp_response::Status", tag = "5")]
    pub status: i32,
    /// Status message
    #[prost(string, optional, tag = "6")]
    pub status_message: ::core::option::Option<::prost::alloc::string::String>,
    /// Status for each permission
    #[prost(message, repeated, tag = "7")]
    pub permission_status: ::prost::alloc::vec::Vec<mcp_response::PermissionStatus>,
    /// Digital signature of canonical response
    #[prost(message, optional, tag = "8")]
    pub signature: ::core::option::Option<CryptoSignature>,
    /// Payload data if request granted
    #[prost(bytes = "bytes", optional, tag = "9")]
    pub response_payload: ::core::option::Option<::prost::bytes::Bytes>,
    /// Consent receipt for auditing
    #[prost(bytes = "bytes", optional, tag = "10")]
    pub consent_receipt: ::core::option::Option<::prost::bytes::Bytes>,
    /// Receipt for compensation
    #[prost(message, optional, tag = "11")]
    pub compensation_receipt: ::core::option::Option<CompensationReceipt>,
    /// Usage limitations on returned data
    #[prost(message, optional, tag = "12")]
    pub usage_limitations: ::core::option::Option<UsageLimitations>,
    /// Additional metadata as needed
    #[prost(message, optional, tag = "13")]
    pub metadata: ::core::option::Option<::prost_types::Struct>,
}
/// Nested message and enum types in `McpResponse`.
pub mod mcp_response {
    /// Permission status details
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PermissionStatus {
        /// Resource identifier
        #[prost(string, tag = "1")]
        pub resource_id: ::prost::alloc::string::String,
        /// Action requested
        #[prost(int32, tag = "2")]
        pub action: i32,
        /// Status code for this specific permission
        #[prost(int32, tag = "3")]
        pub status: i32,
        /// Reason for the status
        #[prost(string, optional, tag = "4")]
        pub reason: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        Unspecified = 0,
        Approved = 1,
        PartiallyApproved = 2,
        Denied = 3,
        Error = 4,
        RequiresUserInput = 5,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Status::Unspecified => "UNSPECIFIED",
                Status::Approved => "APPROVED",
                Status::PartiallyApproved => "PARTIALLY_APPROVED",
                Status::Denied => "DENIED",
                Status::Error => "ERROR",
                Status::RequiresUserInput => "REQUIRES_USER_INPUT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "APPROVED" => Some(Self::Approved),
                "PARTIALLY_APPROVED" => Some(Self::PartiallyApproved),
                "DENIED" => Some(Self::Denied),
                "ERROR" => Some(Self::Error),
                "REQUIRES_USER_INPUT" => Some(Self::RequiresUserInput),
                _ => None,
            }
        }
    }
}
/// Identity information for requestors
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestorIdentity {
    /// Pseudonymous ID for the requestor
    #[prost(string, tag = "1")]
    pub pseudonym_id: ::prost::alloc::string::String,
    /// Human-readable name
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// URL to verify identity
    #[prost(string, optional, tag = "3")]
    pub verification_url: ::core::option::Option<::prost::alloc::string::String>,
    /// Public key for verification
    #[prost(bytes = "bytes", optional, tag = "4")]
    pub public_key: ::core::option::Option<::prost::bytes::Bytes>,
    /// Key ID for the public key
    #[prost(string, optional, tag = "5")]
    pub key_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Reputation score
    #[prost(double, optional, tag = "6")]
    pub reputation_score: ::core::option::Option<f64>,
    /// Additional identity attributes
    #[prost(message, optional, tag = "7")]
    pub attributes: ::core::option::Option<::prost_types::Struct>,
}
/// Identity information for responders
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResponderIdentity {
    /// Pseudonymous ID for the responder
    #[prost(string, tag = "1")]
    pub pseudonym_id: ::prost::alloc::string::String,
    /// Human-readable name
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// URL to verify identity
    #[prost(string, optional, tag = "3")]
    pub verification_url: ::core::option::Option<::prost::alloc::string::String>,
    /// Public key for verification
    #[prost(bytes = "vec", optional, tag = "4")]
    pub public_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// Key ID for the public key
    #[prost(string, optional, tag = "5")]
    pub key_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Additional identity attributes
    #[prost(message, optional, tag = "6")]
    pub attributes: ::core::option::Option<::prost_types::Struct>,
}
/// Digital signature information
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CryptoSignature {
    /// Signature bytes
    #[prost(bytes = "bytes", tag = "1")]
    pub signature: ::prost::bytes::Bytes,
    /// Algorithm used (e.g. "ed25519")
    #[prost(string, tag = "2")]
    pub algorithm: ::prost::alloc::string::String,
    /// Key ID used for signing
    #[prost(string, tag = "3")]
    pub key_id: ::prost::alloc::string::String,
    /// Timestamp when signed
    #[prost(message, optional, tag = "4")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Additional signature metadata
    #[prost(message, optional, tag = "5")]
    pub metadata: ::core::option::Option<::prost_types::Struct>,
}
/// Purpose DNA describes why data is being requested
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PurposeDna {
    /// Human-readable name of the purpose
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Detailed description
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    /// Category of purpose
    #[prost(enumeration = "purpose_dna::PurposeCategory", optional, tag = "3")]
    pub category: ::core::option::Option<i32>,
    /// Primary purpose category (for backward compatibility)
    #[prost(int32, optional, tag = "4")]
    pub primary_purpose_category: ::core::option::Option<i32>,
    /// Purpose identifier for compatibility
    #[prost(string, tag = "5")]
    pub purpose_id: ::prost::alloc::string::String,
    /// Specific purpose description for compatibility
    #[prost(string, tag = "6")]
    pub specific_purpose_description: ::prost::alloc::string::String,
    /// Data types involved in this purpose
    #[prost(string, repeated, tag = "7")]
    pub data_types_involved: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Duration of data use
    #[prost(message, optional, tag = "8")]
    pub usage_duration: ::core::option::Option<purpose_dna::UsageDuration>,
    /// Purpose expiry timestamp for compatibility
    #[prost(message, optional, tag = "9")]
    pub purpose_expiry_timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Whether data will be shared with third parties
    #[prost(message, optional, tag = "10")]
    pub third_party_sharing: ::core::option::Option<purpose_dna::ThirdPartySharing>,
    /// Limitations on data reuse
    #[prost(message, optional, tag = "11")]
    pub reuse_limitations: ::core::option::Option<purpose_dna::ReuseLimitations>,
    /// Links to privacy policy or terms
    #[prost(string, repeated, tag = "12")]
    pub policy_links: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Additional purpose details
    #[prost(message, optional, tag = "13")]
    pub details: ::core::option::Option<::prost_types::Struct>,
}
/// Nested message and enum types in `PurposeDNA`.
pub mod purpose_dna {
    /// How long data will be used
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct UsageDuration {
        /// Duration in seconds, or -1 for indefinite
        #[prost(int64, tag = "1")]
        pub duration_seconds: i64,
        /// Human-readable duration
        #[prost(string, tag = "2")]
        pub duration_text: ::prost::alloc::string::String,
        /// Specific expiration date
        #[prost(message, optional, tag = "3")]
        pub expiration: ::core::option::Option<::prost_types::Timestamp>,
    }
    /// Third party sharing details
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ThirdPartySharing {
        /// Whether data will be shared
        #[prost(bool, tag = "1")]
        pub will_share: bool,
        /// Categories of recipients
        #[prost(string, repeated, tag = "2")]
        pub recipient_categories: ::prost::alloc::vec::Vec<
            ::prost::alloc::string::String,
        >,
        /// Specific named recipients
        #[prost(string, repeated, tag = "3")]
        pub named_recipients: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// Purpose of sharing
        #[prost(string, optional, tag = "4")]
        pub sharing_purpose: ::core::option::Option<::prost::alloc::string::String>,
    }
    /// Reuse limitations
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ReuseLimitations {
        /// Whether data can be used for other purposes
        #[prost(bool, tag = "1")]
        pub allow_repurposing: bool,
        /// Allowed additional purposes
        #[prost(enumeration = "PurposeCategory", repeated, tag = "2")]
        pub allowed_purposes: ::prost::alloc::vec::Vec<i32>,
        /// Required notice before repurposing
        #[prost(bool, tag = "3")]
        pub requires_notice: bool,
        /// Whether reuse requires new consent
        #[prost(bool, tag = "4")]
        pub requires_consent: bool,
    }
    /// Purpose categories
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PurposeCategory {
        Unspecified = 0,
        CoreService = 1,
        Personalization = 2,
        Marketing = 3,
        Analytics = 4,
        Research = 5,
        Legal = 6,
        Security = 7,
        Other = 8,
    }
    impl PurposeCategory {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PurposeCategory::Unspecified => "UNSPECIFIED",
                PurposeCategory::CoreService => "CORE_SERVICE",
                PurposeCategory::Personalization => "PERSONALIZATION",
                PurposeCategory::Marketing => "MARKETING",
                PurposeCategory::Analytics => "ANALYTICS",
                PurposeCategory::Research => "RESEARCH",
                PurposeCategory::Legal => "LEGAL",
                PurposeCategory::Security => "SECURITY",
                PurposeCategory::Other => "OTHER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "CORE_SERVICE" => Some(Self::CoreService),
                "PERSONALIZATION" => Some(Self::Personalization),
                "MARKETING" => Some(Self::Marketing),
                "ANALYTICS" => Some(Self::Analytics),
                "RESEARCH" => Some(Self::Research),
                "LEGAL" => Some(Self::Legal),
                "SECURITY" => Some(Self::Security),
                "OTHER" => Some(Self::Other),
                _ => None,
            }
        }
    }
}
/// Permission being requested
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PermissionSpecification {
    /// Resource identifier
    #[prost(string, tag = "1")]
    pub resource_id: ::prost::alloc::string::String,
    /// Action to perform
    #[prost(enumeration = "permission_specification::Action", optional, tag = "2")]
    pub action: ::core::option::Option<i32>,
    /// Sensitivity level of the data
    #[prost(int32, optional, tag = "3")]
    pub sensitivity_level: ::core::option::Option<i32>,
    /// Resource type
    #[prost(string, optional, tag = "4")]
    pub resource_type: ::core::option::Option<::prost::alloc::string::String>,
    /// Constraints on the permission
    #[prost(message, repeated, tag = "5")]
    pub constraints: ::prost::alloc::vec::Vec<permission_specification::Constraint>,
    /// Permission justification
    #[prost(string, tag = "6")]
    pub justification: ::prost::alloc::string::String,
    /// Delegation chain
    #[prost(message, repeated, tag = "7")]
    pub delegation_chain: ::prost::alloc::vec::Vec<
        permission_specification::DelegationInfo,
    >,
    /// Additional details
    #[prost(message, optional, tag = "8")]
    pub details: ::core::option::Option<::prost_types::Struct>,
}
/// Nested message and enum types in `PermissionSpecification`.
pub mod permission_specification {
    /// Constraint on permission
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Constraint {
        /// Constraint type
        #[prost(string, tag = "1")]
        pub constraint_type: ::prost::alloc::string::String,
        /// Constraint parameters
        #[prost(message, optional, tag = "2")]
        pub parameters: ::core::option::Option<::prost_types::Struct>,
        /// Human-readable description
        #[prost(string, tag = "3")]
        pub description: ::prost::alloc::string::String,
    }
    /// Delegation information
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DelegationInfo {
        /// Who delegated this permission
        #[prost(string, tag = "1")]
        pub delegator_id: ::prost::alloc::string::String,
        /// When delegation was granted
        #[prost(message, optional, tag = "2")]
        pub delegation_time: ::core::option::Option<::prost_types::Timestamp>,
        /// Conditions of delegation
        #[prost(message, optional, tag = "3")]
        pub conditions: ::core::option::Option<::prost_types::Struct>,
        /// Signature from delegator
        #[prost(message, optional, tag = "4")]
        pub signature: ::core::option::Option<super::CryptoSignature>,
    }
    /// Actions that can be performed
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Action {
        Unspecified = 0,
        Read = 1,
        Write = 2,
        Update = 3,
        Delete = 4,
        Execute = 5,
        Query = 6,
        Subscribe = 7,
        Share = 8,
        Extract = 9,
        Infer = 10,
        Process = 11,
    }
    impl Action {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Action::Unspecified => "UNSPECIFIED",
                Action::Read => "READ",
                Action::Write => "WRITE",
                Action::Update => "UPDATE",
                Action::Delete => "DELETE",
                Action::Execute => "EXECUTE",
                Action::Query => "QUERY",
                Action::Subscribe => "SUBSCRIBE",
                Action::Share => "SHARE",
                Action::Extract => "EXTRACT",
                Action::Infer => "INFER",
                Action::Process => "PROCESS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "READ" => Some(Self::Read),
                "WRITE" => Some(Self::Write),
                "UPDATE" => Some(Self::Update),
                "DELETE" => Some(Self::Delete),
                "EXECUTE" => Some(Self::Execute),
                "QUERY" => Some(Self::Query),
                "SUBSCRIBE" => Some(Self::Subscribe),
                "SHARE" => Some(Self::Share),
                "EXTRACT" => Some(Self::Extract),
                "INFER" => Some(Self::Infer),
                "PROCESS" => Some(Self::Process),
                _ => None,
            }
        }
    }
    /// Sensitivity levels
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SensitivityLevel {
        UnspecifiedSensitivity = 0,
        Public = 1,
        Internal = 2,
        Confidential = 3,
        Restricted = 4,
        Secret = 5,
    }
    impl SensitivityLevel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SensitivityLevel::UnspecifiedSensitivity => "UNSPECIFIED_SENSITIVITY",
                SensitivityLevel::Public => "PUBLIC",
                SensitivityLevel::Internal => "INTERNAL",
                SensitivityLevel::Confidential => "CONFIDENTIAL",
                SensitivityLevel::Restricted => "RESTRICTED",
                SensitivityLevel::Secret => "SECRET",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED_SENSITIVITY" => Some(Self::UnspecifiedSensitivity),
                "PUBLIC" => Some(Self::Public),
                "INTERNAL" => Some(Self::Internal),
                "CONFIDENTIAL" => Some(Self::Confidential),
                "RESTRICTED" => Some(Self::Restricted),
                "SECRET" => Some(Self::Secret),
                _ => None,
            }
        }
    }
}
/// Compensation offered for data access
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompensationModel {
    /// Type of compensation
    #[prost(enumeration = "compensation_model::CompensationType", optional, tag = "1")]
    pub r#type: ::core::option::Option<i32>,
    /// Amount offered
    #[prost(double, optional, tag = "2")]
    pub amount: ::core::option::Option<f64>,
    /// Currency code
    #[prost(string, optional, tag = "3")]
    pub currency_code: ::core::option::Option<::prost::alloc::string::String>,
    /// Payment method details
    #[prost(message, optional, tag = "4")]
    pub payment_method: ::core::option::Option<compensation_model::PaymentMethod>,
    /// Revenue sharing details if applicable
    #[prost(message, optional, tag = "5")]
    pub revenue_sharing: ::core::option::Option<compensation_model::RevenueSharing>,
    /// Additional compensation details
    #[prost(message, optional, tag = "6")]
    pub details: ::core::option::Option<::prost_types::Struct>,
}
/// Nested message and enum types in `CompensationModel`.
pub mod compensation_model {
    /// Payment method details
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PaymentMethod {
        /// Method type (e.g. "crypto", "bank", "credit_card")
        #[prost(string, tag = "1")]
        pub method_type: ::prost::alloc::string::String,
        /// Account/wallet identifier
        #[prost(string, optional, tag = "2")]
        pub account_id: ::core::option::Option<::prost::alloc::string::String>,
        /// Provider name
        #[prost(string, optional, tag = "3")]
        pub provider: ::core::option::Option<::prost::alloc::string::String>,
        /// Additional payment method details
        #[prost(message, optional, tag = "4")]
        pub details: ::core::option::Option<::prost_types::Struct>,
    }
    /// Revenue sharing details
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RevenueSharing {
        /// Revenue share percentage
        #[prost(double, tag = "1")]
        pub percentage: f64,
        /// How often payments will be made
        #[prost(string, optional, tag = "2")]
        pub payment_frequency: ::core::option::Option<::prost::alloc::string::String>,
        /// Minimum payment threshold
        #[prost(double, optional, tag = "3")]
        pub minimum_threshold: ::core::option::Option<f64>,
        /// Rules for calculating revenue
        #[prost(message, optional, tag = "4")]
        pub rules: ::core::option::Option<::prost_types::Struct>,
    }
    /// Types of compensation
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CompensationType {
        UnspecifiedCompensation = 0,
        Monetary = 1,
        RevenueSharing = 2,
        Credit = 3,
        Token = 4,
        Reputation = 5,
        FreeService = 6,
        None = 7,
    }
    impl CompensationType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CompensationType::UnspecifiedCompensation => "UNSPECIFIED_COMPENSATION",
                CompensationType::Monetary => "MONETARY",
                CompensationType::RevenueSharing => "REVENUE_SHARING",
                CompensationType::Credit => "CREDIT",
                CompensationType::Token => "TOKEN",
                CompensationType::Reputation => "REPUTATION",
                CompensationType::FreeService => "FREE_SERVICE",
                CompensationType::None => "NONE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED_COMPENSATION" => Some(Self::UnspecifiedCompensation),
                "MONETARY" => Some(Self::Monetary),
                "REVENUE_SHARING" => Some(Self::RevenueSharing),
                "CREDIT" => Some(Self::Credit),
                "TOKEN" => Some(Self::Token),
                "REPUTATION" => Some(Self::Reputation),
                "FREE_SERVICE" => Some(Self::FreeService),
                "NONE" => Some(Self::None),
                _ => None,
            }
        }
    }
}
/// Trust credentials and attestations
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TrustInformation {
    /// Credentials (verifiable credentials, certificates)
    #[prost(message, repeated, tag = "1")]
    pub credentials: ::prost::alloc::vec::Vec<trust_information::Credential>,
    /// Attestations from trusted parties
    #[prost(message, repeated, tag = "2")]
    pub attestations: ::prost::alloc::vec::Vec<trust_information::Attestation>,
    /// Reputation score or level
    #[prost(double, optional, tag = "3")]
    pub reputation_score: ::core::option::Option<f64>,
    /// Proof of trustworthiness
    #[prost(message, optional, tag = "4")]
    pub proof: ::core::option::Option<trust_information::Proof>,
    /// Additional trust information
    #[prost(message, optional, tag = "5")]
    pub details: ::core::option::Option<::prost_types::Struct>,
}
/// Nested message and enum types in `TrustInformation`.
pub mod trust_information {
    /// Credential information
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Credential {
        /// Credential type
        #[prost(string, tag = "1")]
        pub credential_type: ::prost::alloc::string::String,
        /// Issuer of the credential
        #[prost(string, tag = "2")]
        pub issuer: ::prost::alloc::string::String,
        /// When the credential was issued
        #[prost(message, optional, tag = "3")]
        pub issuance_date: ::core::option::Option<::prost_types::Timestamp>,
        /// When the credential expires
        #[prost(message, optional, tag = "4")]
        pub expiration_date: ::core::option::Option<::prost_types::Timestamp>,
        /// Credential data (e.g. JSON-LD)
        #[prost(message, optional, tag = "5")]
        pub credential_data: ::core::option::Option<::prost_types::Struct>,
        /// Cryptographic proof
        #[prost(bytes = "vec", optional, tag = "6")]
        pub proof: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    }
    /// Attestation from a trusted party
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Attestation {
        /// Attestation type
        #[prost(string, tag = "1")]
        pub attestation_type: ::prost::alloc::string::String,
        /// Who made the attestation
        #[prost(string, tag = "2")]
        pub attester: ::prost::alloc::string::String,
        /// When the attestation was made
        #[prost(message, optional, tag = "3")]
        pub attestation_date: ::core::option::Option<::prost_types::Timestamp>,
        /// Content of the attestation
        #[prost(string, tag = "4")]
        pub content: ::prost::alloc::string::String,
        /// Signature on the attestation
        #[prost(message, optional, tag = "5")]
        pub signature: ::core::option::Option<super::CryptoSignature>,
    }
    /// Proof of trustworthiness
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Proof {
        /// Proof type
        #[prost(string, tag = "1")]
        pub proof_type: ::prost::alloc::string::String,
        /// Proof data
        #[prost(message, optional, tag = "2")]
        pub proof_data: ::core::option::Option<::prost_types::Struct>,
        /// Challenge if applicable
        #[prost(string, optional, tag = "3")]
        pub challenge: ::core::option::Option<::prost::alloc::string::String>,
        /// Verification method to use
        #[prost(string, optional, tag = "4")]
        pub verification_method: ::core::option::Option<::prost::alloc::string::String>,
    }
}
/// Authentication information
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuthenticationInfo {
    /// Authentication method used
    #[prost(string, tag = "1")]
    pub auth_method: ::prost::alloc::string::String,
    /// Authentication token or proof
    #[prost(bytes = "vec", optional, tag = "2")]
    pub auth_token: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// Authentication timestamp
    #[prost(message, optional, tag = "3")]
    pub auth_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Additional authentication claims
    #[prost(message, optional, tag = "4")]
    pub claims: ::core::option::Option<::prost_types::Struct>,
    /// For multi-factor auth, factors used
    #[prost(string, repeated, tag = "5")]
    pub auth_factors_used: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Authentication provider
    #[prost(string, optional, tag = "6")]
    pub auth_provider: ::core::option::Option<::prost::alloc::string::String>,
}
/// Receipt for compensation
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompensationReceipt {
    /// Unique receipt ID
    #[prost(string, tag = "1")]
    pub receipt_id: ::prost::alloc::string::String,
    /// Amount paid
    #[prost(double, tag = "2")]
    pub amount: f64,
    /// Currency code
    #[prost(string, tag = "3")]
    pub currency_code: ::prost::alloc::string::String,
    /// When payment was made
    #[prost(message, optional, tag = "4")]
    pub payment_timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Payment status
    #[prost(enumeration = "compensation_receipt::PaymentStatus", tag = "5")]
    pub status: i32,
    /// Transaction ID or reference
    #[prost(string, optional, tag = "6")]
    pub transaction_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Payment method used
    #[prost(string, optional, tag = "7")]
    pub payment_method: ::core::option::Option<::prost::alloc::string::String>,
    /// Additional receipt data
    #[prost(message, optional, tag = "8")]
    pub details: ::core::option::Option<::prost_types::Struct>,
}
/// Nested message and enum types in `CompensationReceipt`.
pub mod compensation_receipt {
    /// Payment statuses
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PaymentStatus {
        UnspecifiedPayment = 0,
        Pending = 1,
        Completed = 2,
        Failed = 3,
        Refunded = 4,
        Disputed = 5,
    }
    impl PaymentStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PaymentStatus::UnspecifiedPayment => "UNSPECIFIED_PAYMENT",
                PaymentStatus::Pending => "PENDING",
                PaymentStatus::Completed => "COMPLETED",
                PaymentStatus::Failed => "FAILED",
                PaymentStatus::Refunded => "REFUNDED",
                PaymentStatus::Disputed => "DISPUTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED_PAYMENT" => Some(Self::UnspecifiedPayment),
                "PENDING" => Some(Self::Pending),
                "COMPLETED" => Some(Self::Completed),
                "FAILED" => Some(Self::Failed),
                "REFUNDED" => Some(Self::Refunded),
                "DISPUTED" => Some(Self::Disputed),
                _ => None,
            }
        }
    }
}
/// Limitations on data usage
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UsageLimitations {
    /// Time-based limitations
    #[prost(message, optional, tag = "1")]
    pub time_limitations: ::core::option::Option<usage_limitations::TimeLimitations>,
    /// Scope limitations
    #[prost(message, optional, tag = "2")]
    pub scope_limitations: ::core::option::Option<usage_limitations::ScopeLimitations>,
    /// Distribution limitations
    #[prost(message, optional, tag = "3")]
    pub distribution_limitations: ::core::option::Option<
        usage_limitations::DistributionLimitations,
    >,
    /// Processing limitations
    #[prost(message, optional, tag = "4")]
    pub processing_limitations: ::core::option::Option<
        usage_limitations::ProcessingLimitations,
    >,
    /// Additional limitations
    #[prost(message, optional, tag = "5")]
    pub additional_limitations: ::core::option::Option<::prost_types::Struct>,
}
/// Nested message and enum types in `UsageLimitations`.
pub mod usage_limitations {
    /// Time-based limitations
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TimeLimitations {
        /// Max duration in seconds
        #[prost(int64, tag = "1")]
        pub max_duration_seconds: i64,
        /// Absolute expiry timestamp
        #[prost(message, optional, tag = "2")]
        pub expiry_timestamp: ::core::option::Option<::prost_types::Timestamp>,
        /// Max number of uses
        #[prost(int32, optional, tag = "3")]
        pub max_uses: ::core::option::Option<i32>,
    }
    /// Scope limitations
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ScopeLimitations {
        /// Allowed purposes
        #[prost(
            enumeration = "super::purpose_dna::PurposeCategory",
            repeated,
            tag = "1"
        )]
        pub allowed_purposes: ::prost::alloc::vec::Vec<i32>,
        /// Allowed contexts
        #[prost(string, repeated, tag = "2")]
        pub allowed_contexts: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// Geographic restrictions
        #[prost(string, repeated, tag = "3")]
        pub geographic_restrictions: ::prost::alloc::vec::Vec<
            ::prost::alloc::string::String,
        >,
    }
    /// Distribution limitations
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DistributionLimitations {
        /// Whether sharing is prohibited
        #[prost(bool, tag = "1")]
        pub sharing_prohibited: bool,
        /// Allowed recipients
        #[prost(string, repeated, tag = "2")]
        pub allowed_recipients: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// Prohibited recipients
        #[prost(string, repeated, tag = "3")]
        pub prohibited_recipients: ::prost::alloc::vec::Vec<
            ::prost::alloc::string::String,
        >,
        /// Whether derivations are allowed
        #[prost(bool, tag = "4")]
        pub derivations_allowed: bool,
    }
    /// Processing limitations
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ProcessingLimitations {
        /// Prohibited operations
        #[prost(
            enumeration = "processing_limitations::ProcessingLimitation",
            repeated,
            tag = "1"
        )]
        pub prohibited_operations: ::prost::alloc::vec::Vec<i32>,
        /// Required protections
        #[prost(string, repeated, tag = "2")]
        pub required_protections: ::prost::alloc::vec::Vec<
            ::prost::alloc::string::String,
        >,
        /// How data must be stored
        #[prost(string, optional, tag = "3")]
        pub storage_requirements: ::core::option::Option<::prost::alloc::string::String>,
    }
    /// Nested message and enum types in `ProcessingLimitations`.
    pub mod processing_limitations {
        /// Types of processing limitations
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum ProcessingLimitation {
            UnspecifiedLimitation = 0,
            NoIdentification = 1,
            NoSensitiveInference = 2,
            NoProfiling = 3,
            NoAutomatedDecisions = 4,
            NoMarketing = 5,
            NoLargeLanguageModels = 6,
            NoTraining = 7,
        }
        impl ProcessingLimitation {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    ProcessingLimitation::UnspecifiedLimitation => {
                        "UNSPECIFIED_LIMITATION"
                    }
                    ProcessingLimitation::NoIdentification => "NO_IDENTIFICATION",
                    ProcessingLimitation::NoSensitiveInference => {
                        "NO_SENSITIVE_INFERENCE"
                    }
                    ProcessingLimitation::NoProfiling => "NO_PROFILING",
                    ProcessingLimitation::NoAutomatedDecisions => {
                        "NO_AUTOMATED_DECISIONS"
                    }
                    ProcessingLimitation::NoMarketing => "NO_MARKETING",
                    ProcessingLimitation::NoLargeLanguageModels => {
                        "NO_LARGE_LANGUAGE_MODELS"
                    }
                    ProcessingLimitation::NoTraining => "NO_TRAINING",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNSPECIFIED_LIMITATION" => Some(Self::UnspecifiedLimitation),
                    "NO_IDENTIFICATION" => Some(Self::NoIdentification),
                    "NO_SENSITIVE_INFERENCE" => Some(Self::NoSensitiveInference),
                    "NO_PROFILING" => Some(Self::NoProfiling),
                    "NO_AUTOMATED_DECISIONS" => Some(Self::NoAutomatedDecisions),
                    "NO_MARKETING" => Some(Self::NoMarketing),
                    "NO_LARGE_LANGUAGE_MODELS" => Some(Self::NoLargeLanguageModels),
                    "NO_TRAINING" => Some(Self::NoTraining),
                    _ => None,
                }
            }
        }
    }
}
